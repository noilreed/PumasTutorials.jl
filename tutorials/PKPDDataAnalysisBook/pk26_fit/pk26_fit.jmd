---
title : Exercise PK26 - Fitting of antibody kinetics after IV doses to man
date: `j Date(now())`
---

```julia; echo = false
using Dates
```

## Objectives

In this exercise we have obtained data from Baeur _et al_. We will use a semi-physiologic
  model for the estimation of the given data. The data displays a nonlinear pattern,
  and the antibody is modeled by means of **parallel first-order and Michaelis-Menten**
  process.

The basic workflow of the estimation process is

 1. Description of the data
 2. Exploratory analysis of the data
 3. NCA Analysis
 4. Pharmacokinetic modelling
 5. Diagnostic Plots
 6. Validation

Lets load the necessary `libraries` before we get started

```julia
using PumasTutorials
using Random
using CSV
using Pumas
using Plots
using StatsPlots
using Pipe
using StatsBase
```

## Description of the data

The antibody is given as an Intravenous Bolus to `5` groups of 5 subjects each.
 The doses given to **group 1: 0.1 mg/kg, group 2: 0.3 mg/kg, group 3: 1 mg/kg,**
 **group 4: 3 mg/kg and group 5: 10 mg/kg**. Plasma samples are collected at various
 time intervals.

The following are the units of the dataset:

 * Time (time) = days
 * Plasma Concentration (dv) = mg/L
 * Dose (amt) = mg/kg

```julia
pk26_data_df = CSV.read("/Users/Parsshava/Desktop/Julia/PumasTutorials.jl/tutorials/PKPDDataAnalysisBook/pk26_fit/pk_26.csv",
 DataFrame, missingstrings=["", ".", "NA", "BQL"])
```

Basic summary `statistics` of the data

```julia
stats_pk26_data = describe(pk26_data_df, :min, :max, :mean, :std, :nmissing, cols=[:id,:time,:dv])
```

## Exploratory Plots of the given data

* Plot of Plasma Concentration vs Time

```julia
pk_data_plot = dropmissing(pk26_data_df, :dv)
@df pk_data_plot plot(:time, :dv, group=:id, yaxis=:log, color=:Group, label=false,
                       xlabel="Time (days)", ylabel="Concentration (mg/L)",
                       size = (600, 500), guidefontsize = 12,
                       title = "Plasma Concentrations vs Time")
```

## NCA Analysis

We will now perform an NCA analysis to make a few interpretations of the given data.
 The **read_nca()** function input requires the route to be stated as `iv` for intravenous
 bolus.

```julia; results="hidden"
pk26_data_df[:, :route] .= "iv"
```

Now, map the data variables to the **read_nca** function that prepares the data
 for NCA analysis. You can even type **?read_nca** in the REPL and get more
 information on the mapping of the variables. We will group the data by `Dose`, this
 will provide information on the parameters for each dose seperately.

```julia
pk26_nca = read_nca(pk26_data_df,
                    id       = :id,
                    time     = :time,
                    amt      = :amt,
                    conc     = :dv,
                    route    = :route,
                    group    = [:Dose])
```

A `full NCAReport` is generated, we will then perform summary statistics of the
 required parameters to obtain the **Mean and SD**

```julia
pk26_nca_report = NCAReport(pk26_nca, sigdig=3)
```

Perform the `Summary Statistics` for the required NCA Parameters

```julia
## Select the required parameters from the NCA Report
stats_nca_df = select(pk26_nca_report, [:id, :vz_obs, :cl_obs, :kel, :half_life, :aucinf_obs, :Dose])

## Stack the data for easy computation
stats_nca_stacked = stack(stats_nca_df, [:vz_obs, :cl_obs, :kel, :half_life, :aucinf_obs], [:id, :Dose])
stats_nca_summary = combine(groupby(stats_nca_stacked,[:variable, :Dose]),
                            [col => fun for col in [:value]
                            for fun in [mean, std]])
```

We will plot the **Clearance vs Dose**. This will help us understand the relation
 and make further decisions in the modelling of the given data.

```julia
cl = select(pk26_nca_report, [:id, :Dose, :cl_obs])
#TODO unable to get ordered x-axis
cl[!,:Dose] .= CategoricalArray(cl.Dose)
@df cl groupedviolin(:Dose, :cl_obs, group=:Dose,
                      marker=(0.2,:blue,stroke(0)))
@df cl groupedboxplot!(:Dose, :cl_obs, group=:Dose, label="",
                      marker=(0.1,:orange,stroke(2)), alpha=0.5)
plot!(size = (600,600), xlabel = "Dose (mg/kg)", ylabel = "Clearance", legend=:topright,
   guidefontsize = 16, alpha=0.5)
```

## Pharmacokinetic Modelling

##### Read the dataset into read_pumas()

```julia
pk26_est_df = filter(x -> (!(x.time == 0  && x.evid == 0.0)), pk26_data_df)

pk26_data  = read_pumas(pk26_est_df,
                        id           = :id,
                        time         = :time,
                        observations = [:dv],
                        amt          = :amt,
                        evid         = :evid,
                        cmt          = :cmt,
                        covariates   = [:Dose, :Group])
```

##### Two-compartment model with Parallel First-order and Nonlinear Elimination

```julia
pk_26           = @model begin
  @param begin
    tvvmax      ∈ RealDomain(lower=0)
    tvkm        ∈ RealDomain(lower=0)
    tvvp        ∈ RealDomain(lower=0)
    tvvc        ∈ RealDomain(lower=0)
    tvq         ∈ RealDomain(lower=0)
    tvcll       ∈ RealDomain(lower=0)
    Ω           ∈ PDiagDomain(3)
    σ²_prop     ∈ RealDomain(lower=0)
  end

  @random begin
    η           ~ MvNormal(Ω)
  end

  @pre begin
    Vmax        = tvvmax * exp(η[1])
    Km          = tvkm
    Vp          = tvvp * exp(η[2])
    Vc          = tvvc
    Q           = tvq
    CLl         = tvcll * exp(η[3]) # Linear elimination
   end

  @vars begin
    Clmm       := (Vmax/(Km+(Central/Vc))) # Nonlinear elimination
  end

  @dynamics begin
    Central'    = -Clmm*(Central/Vc) - CLl*(Central/Vc)-(Q/Vc)*Central +(Q/Vp)*Peripheral
    Peripheral' = (Q/Vc)*Central -(Q/Vp)*Peripheral
  end

  @derived begin
    cp          = @. Central/Vc
    dv          ~ @. Normal(cp, sqrt(cp^2*σ²_prop))
  end
end
```

We have obtained the inital estimates from the `literature`.

```julia
param_est = ( tvvmax  = 0.04,
              tvkm    = 0.09,
              tvvp    = 0.01,
              tvvc    = 0.09,
              tvq     = 0.01,
              tvcll   = 0.007,
              Ω       = Diagonal([0.02,0.02,0.02]),
              σ²_prop = 0.02)
```

##### NaivePooled Analysis

A quick estimation of the mean parameters can be done by performing a NaivePooled Analysis.
 This will give us a good judgemnt of the initial parameters obtained from literature
 and provide better inital estimates for the fitting.

```julia
pk_26_fit_nv= @time fit(pk_26, pk26_data, param_est,
                       Pumas.NaivePooled(), ensemblealg = EnsembleThreads(),
                       omegas=(:Ω,))

coeftable(pk_26_fit_nv)
```

We will now fit the data using `FOCEI` and let the system find the best
 local minima.

```julia
pk_26_fit= @time fit(pk_26, pk26_data, param_est,
                       Pumas.FOCEI(), ensemblealg = EnsembleThreads())

coeftable(pk_26_fit)
```

We will now obtain the parameter `precision` of the model.

```julia
pk_26_infer = coeftable(infer(pk_26_fit))
```

We will generate a few goodness of fit plots to check the trends in the model.
 We will first `inspect` the diagnostics of our models.

```julia
pk_26_inspect = inspect(pk_26_fit) |> DataFrame
```

## Diagnostic Plots

##### Goodness of Fit Plots

```julia
theme(:wong2)

function gof(pktvp_mr_inspect_run2)
  p1 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
      p1,
      :dv_pred, :dv;
      ylabel = "Observed dv (mg/L)",
      xlabel = "Population Predicted (mg/L)",
      label = "",
      legend=false,
  )
  Plots.abline!(p1,  1, 0; primary = false, color=:red, linewidth=4)

  #
  p2 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
    p2,
    :dv_ipred, :dv;
    ylabel = "Observed dv (mg/L)",
    xlabel = "Individual Predicted (mg/L)",
    label = "",
    legend=false,
  )
  Plots.abline!(p2, 1, 0; primary = false, color=:red, linewidth=4)

  p3 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
    p3,
    :time, :dv_wres;
    xlabel = "Time (days)",
    ylabel = "Conditional Weighted Residuals",
     legend=false
  )
  Plots.abline!(p3, 0, 0; primary = false, color=:red, linewidth=4)

  p4 = plot()
  @df pktvp_mr_inspect_run2 scatter!(
   p4,
   :dv_pred, :dv_wres,
   xlabel = "Population Predicted (mg/L)",
   ylabel = "Conditional Weighted Residuals",
   legend=false
  )
  Plots.abline!(p4, 0, 0; primary = false, color=:red, linewidth=4)

  return plot(p1,p2,p3,p4; size = (1000, 1000))
end

gof(pk_26_inspect)
```

##### η-Distribution

```julia
data26_etacov = select(pk_26_inspect,["η_1", "η_2", "η_3"])
data26_etacov = stack(data26_etacov, ["η_1", "η_2", "η_3"])
data26_etacov[!,:variable] .= string.(data26_etacov.variable)
@df data26_etacov groupedviolin(:variable,:value,
                               alpha =0.5, legend=false)
@df data26_etacov groupedboxplot!(:variable,:value,
                               alpha =0.5, label ="")
Plots.abline!(0,0, linewidth=4, color = "black",
              size = (600, 600),
              xlabel = "η's", ylabel = "η_values",
              guidefontsize = 22,
              tickfontsize =14, label ="")
```

## Validation

We will perform a validation of the final model using a `Visual Predictive Check`.

```julia
pk_vpc = vpc(pk_26_fit, 200; dv=:dv,
             stratify_by=[:Group],
             ensemblealg=EnsembleSerial())

plot(pk_vpc,
     size=(1200,1200), xlabel="Time after dose (days)",
     ylabel = "Concentration (mg/L)" ,
     titlefontsize=20,guidefontsize=20,
     markersize=7, markeralpha = 0.5, markercolor =:grey,
     observations = true,
     observed_quantiles = true,
     simquantile_medians = true,
     ci_bands = true,
     legend=true, legendfontsize = 12,
     titlefontcolor = :blue,
     linewidth = 5,
     xtickfont = font(20),
     ytickfont = font(20))
```
