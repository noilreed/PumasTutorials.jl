---
title: Exercise PK37 - Fitting In vitro/In vivo Extrapolation I
date: `j Date(now())`
---

```julia; echo = false
using Dates
```

## Objectives

In this exercise you will learn how to model _in vitro_ concentrations. A new drug
 is developed for hypertension and hence we require to obtain the bioavailability,
 an expirement is performed using human microsomes. This will help us to obtain the
 Vmax and Km.

The basic workflow for the estimation process is:

 1. Description of the data
 2. Exploratory analysis of the data
 3. Pharmacokinetic modelling
 4. Diagnostic Plots
 5. Validation
 6. Simulation

Lets load the necessary `libraries` before we get started

```julia
using PumasTutorials
using Random
using CSV
using Pumas
using Plots
using StatsPlots
using Pipe
using StatsBase
```

## Description of the given data

In this experiment `55 human microsome` samples are tested at various concentrations
  at `0.02, 0.05, 0.1, 0.2, 0.5, 1, 10, 20, 50, 100, 180, 200, 250, 500, 1000, 2000`.

The following are the units of the dataset:

 * Time (time) = mins
 * Rate (dv_rate) = umol/g/min
 * Substrate Concentration (Conc) = μM

```julia
pk37_data_df = CSV.read("./pk_37.csv", DataFrame, missingstrings = ["", ".", "NA", "BQL"])
```

Basic summary `statistics` of the data

```julia
stats_pk37_data = describe(pk37_data_df, :min, :max, :mean, :std, :nmissing, cols=[:id,:time,:dv_rate])
```

## Exploratory Plots of the given data

 * Plot of Rate vs Substrate Concentration

```julia
pk_data_plot = dropmissing(pk37_data_df, :dv_rate)
@df pk_data_plot plot(:Conc, :dv_rate, group=:id, label=false,
                      xlabel="Concentration (uM)", ylabel="Rate (umol/g/min)",
                      size = (600, 600), guidefontsize = 12,
                      title = "Rate vs Concentration")
```

 * Plot of Rate vs Substrate Concentration - Log Scale

```julia
@df pk_data_plot plot(:Conc, :dv_rate, group=:id, xaxis=:log, label=false,
                      xlabel="Concentration (uM)", ylabel="Rate (umol/g/min)",
                      size = (600, 600), guidefontsize = 12,
                      title = "Rate vs Concentration")
```

 * Plot of Mean Rate vs Substrate Concentration

```julia
plasma_mean = combine(groupby(pk37_data_df,[:Conc]),
                             [col => fun for col in [:dv_rate]
                             for fun in [mean, std]])

@df plasma_mean plot(:Conc, :dv_rate_mean, label=false,
                      xlabel="Concentration (uM)", ylabel="Rate (umol/g/min)",
                      size = (600, 500), guidefontsize = 12, linewidth=3,
                      title = "Rate vs Concentration")
```

 * Plot of Mean Rate vs Substrate Concentration - Log Scale

```julia
@df plasma_mean plot(:Conc, :dv_rate_mean, xaxis=:log, label=false,
                      xlabel="Concentration (uM)", ylabel="Rate (umol/g/min)",
                      size = (600, 500), guidefontsize = 12, linewidth=3,
                      title = "Rate vs Concentration")
```

We will use the `graphical representation` for the initial parameter estimates for
 the fitiing of the given data.


## Pharmacokinetic Modelling

##### Read the dataset into read_pumas()

```julia
pk37_data = read_pumas(pk37_data_df,
                        id           = :id,
                        time         = :time,
                        observations = [:dv_rate],
                        covariates   = [:Conc],
                        event_data   = false)
```

##### Single-Enzyme System

```julia
pk_37_one   = @emmodel begin
  @metadata begin
    desc = "PK37 Single Enzyme System Model"
    timeu = u"hr"
  end

  @random begin
    Vmax1   ~ 1 | LogNormal
    Km1     ~ 1 | LogNormal
  end

  @covariates Conc

  @pre begin
    _Conc = Conc
  end

  @post begin
    rate    = Vmax1*_Conc/(Km1+_Conc)
  end

  @error begin
    dv_rate ~ Normal(rate)
  end
end
```

We have obtained the initial estimates from the Mean Rate vs Concentration plot.

```julia
param_est_one = ( Vmax1 = 3,
                  Km1   = 250)
```

##### SAEM Fitting

We will now fit the data using `SAEM`

```julia
pk_37_one_fit = @time fit(pk_37_one, pk37_data, param_est_one,
                          Pumas.SAEM(), ensemblealg=EnsembleThreads())

coeftable(pk_37_one_fit)
```


##### Double-Enzyme System with Proportional Error

```julia
pk_37_two_prop = @model begin
  @param begin
    tvvmax1 ∈ RealDomain(lower=0)
    tvkm1   ∈ RealDomain(lower=0)
    tvvmax2 ∈ RealDomain(lower=0)
    tvkm2   ∈ RealDomain(lower=0)
    Ω       ∈ PDiagDomain(3)
    σ²_prop ∈ RealDomain(lower=0)
  end

  @random begin
    η       ~ MvNormal(Ω)
  end

  @covariates Conc

  @pre begin
    Vmax1   = tvvmax1 * exp(η[1])
    Km1     = tvkm1 * exp(η[2])
    Vmax2   = tvvmax2 * exp(η[3])
    Km2     = tvkm2
    _Conc   = Conc
  end

  @derived begin
    rate    = @. ((Vmax1*_Conc/(Km1+_Conc)) + (Vmax2*_Conc/(Km2+_Conc)))
    dv_rate ~ @. Normal(rate, sqrt(rate^2*σ²_prop))
  end
end
```

Initial Estimates

```julia
param_two_prop_est = ( tvvmax1 = 3,
                       tvkm1   = 250,
                       tvvmax2 = 0.5,
                       tvkm2   = 2,
                       Ω       = Diagonal([0.04,0.02,0.02]),
                       σ²_prop = 0.001)
```

We will now fit the data using `FOCEI`

```julia
pk_37_two_prop_fit = @time fit(pk_37_two_prop, pk37_data, param_two_prop_est,
                               Pumas.FOCEI(), ensemblealg=EnsembleThreads())

coeftable(pk_37_two_prop_fit)
```

We will `inspect` the diagnostics of the model before we go for the goodness of fit plots.

```julia
pk_37_two_prop_inspect = inspect(pk_37_two_prop_fit) |> DataFrame
```

 * Goodness of Fit Plots

```julia
gof(pk_37_two_prop_inspect)
```

##### Double-Enzyme System with Additive Error

```julia
pk_37_two_add = @model begin
  @param begin
    tvvmax1 ∈ RealDomain(lower=0)
    tvkm1   ∈ RealDomain(lower=0)
    tvvmax2 ∈ RealDomain(lower=0)
    tvkm2   ∈ RealDomain(lower=0)
    Ω       ∈ PDiagDomain(3)
    σ_add   ∈ RealDomain(lower=0)
  end

  @random begin
    η       ~ MvNormal(Ω)
  end

  @covariates Conc

  @pre begin
    Vmax1   = tvvmax1 * exp(η[1])
    Km1     = tvkm1 * exp(η[2])
    Vmax2   = tvvmax2 * exp(η[3])
    Km2     = tvkm2
    _Conc   = Conc
  end

  @derived begin
    rate    = @. ((Vmax1*_Conc/(Km1+_Conc)) + (Vmax2*_Conc/(Km2+_Conc)))
    dv_rate ~ @. Normal(rate, σ_add)
  end
end
```

Initial Estimates

```julia
param_two_add_est = ( tvvmax1 = 3,
                      tvkm1   = 250,
                      tvvmax2 = 0.5,
                      tvkm2   = 2,
                      Ω       = Diagonal([0.04,0.02,0.02]),
                      σ_add   = 0.05)
```

We will fit the data using `FOCEI`

```julia
pk_37_two_add_fit = @time fit(pk_37_two_add, pk37_data, param_two_add_est,
                      Pumas.FOCEI(), ensemblealg=EnsembleThreads())

coeftable(pk_37_two_add_fit)
```

We will obtain the `precision` of the parameters

```julia
pk_37_two_add_infer = coeftable(infer(pk_37_two_add_fit))
```

We will `inspect` the diagnostics of the model before we go for the goodness of fit plots.

```julia
pk_37_two_add_inspect = inspect(pk_37_two_add_fit) |> DataFrame
```

 * Goodness of fit plots

```julia
gof(pk_37_two_add_inspect)
```

We will compare other metrics and statistics, such as aic and bic. The aic
 and bic values are **lower for the double-enzyme model with additive error**
 which indicates a better fit of the model.

```julia
DataFrame([(metric=string(f), fit_single_enz=f(pk_37_one_fit), fit_double_enz_prop=f(pk_37_two_prop_fit),
 fit_double_enz_add=f(pk_37_two_add_fit)) for f in (aic, bic)])
```

