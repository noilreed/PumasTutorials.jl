---
title: A comprehensive introduction to Pumas - Part 2
date: `j Date(now())`
---

```julia; echo = false
using Dates
```

# Introduction

In [part-1]() of this tutorial, we modeled the pharmacokinetics of _CTMNopain_ an analgesic at three
dose levels. In this tutorial, we will explore the relation between drug exposures and pain scores.

Pain score (0=no pain, 1=mild, 2=moderate, 3=severe) were obtained at time points
when plasma concentration was collected.  A pain score of 2 or more is considered
as no pain relief.

The subjects requested for remedication if pain relief was not achieved after 2 hours post dose.
Some subjects had remedication before 2 hours if they were not able to bear the pain.
The time to remedication and the remedication status is available for subjects.

We will cover four different kinds of analysis in this tutorial:

1. Logistic regression of pain score
2. Ordinal regression of pain score
3. Time to remedication
4. Relation of _CTMNopain_ exposures to each of these end points. 

## Setup

### Load libraries

Two libraries provide the workhorse functionality in the Pumas ecosystem that we will load:

```julia; results = "hidden"
using Pumas
using PumasUtilities
using GLM: lm, @formula
using Random
using CSV
using HTTP
using Chain
using Latexify
using CairoMakie 
using StatsBase
using DataFrames
using ColorSchemes
using Survival
interactive!(false)
```

### Exploratory Analysis

Let's read the same data as in part-1 of the tutorial.

```julia; results = "hidden"
f = CSV.File(HTTP.get("http://bit.ly/painremed").body, 
             missingstrings=["", "NA", "."])

pkpain_df = DataFrame(f)
pkpain_df[!, :dosenum] .=  ifelse.(pkpain_df.Dose .== "Placebo",  0,
                           ifelse.(pkpain_df.Dose .== "5 mg", 5,
                           ifelse.(pkpain_df.Dose .== "20 mg", 20, 80)))
transform!(groupby(pkpain_df, :Subject), :Conc => maximum => :cmax)                           
```

```julia
color_indices = groupindices(groupby(pkpain_df, [:Dose]))
palette = ColorSchemes.tab10.colors
f = Figure(resolution = (1000, 800))
ax = f[1,1] = Axis(f, 
                    xlabel="Time (hr)", 
                    ylabel="Proportion of Pain Relief", 
                    title = "Pain Score Trends for CTMNopain")
@chain pkpain_df begin
    combine(groupby(_, [:Time, :dosenum]), :PainRelief => mean, ungroup=true)
    for (i, gdf) in enumerate(groupby(_, [:dosenum], sort=true))
        barplot!(ax,
                gdf.Time, 
                gdf.PainRelief_mean, 
                dodge = unique(gdf.dosenum),
                color = (palette[i], 0.5)
            )
            ax.yticks = 0:0.1:1
    end
end
f
```

```julia
#ggdf = groupby(pkpain_df, [:dosenum])
#for (i, (k,v)) in enumerate(pairs(ggdf))
#    println(v.Time)
#end
props = combine(groupby(pkpain_df, [:Time, :dosenum]), :PainRelief => mean, ungroup=true)
function example_plot(df)
    f = Figure()
    for ((i, j), g) in zip(Iterators.product((1, 2), (1, 2)), groupby(df, :dosenum; sort = true))
        ax = Axis(f[i, j])
        barplot!(ax, g.Time, g.PainRelief_mean)
        ylims!(ax, (0, 1))
    end
    f
end
example_plot(props)
```

### Logistic regression of pain relief

```julia
painrelief = read_pumas(pkpain_df,
                          id           = :Subject,
                          time         = :Time,
                          amt          = :amt,
                          observations = [:PainRelief],
                          covariates   = [:dosenum, :cmax, :Conc],
                          event_data   = false)
```

```julia                          
trt_model = @model begin
    @metadata begin
        desc = "Logistic Regression Model"
    end
    @param begin
        "Intercept"
        intercept ∈ RealDomain(init=0.001)
        "Slope"
        tvslope ∈ RealDomain(init=0.0001)
        """
         - Ω
        """
        Ω ∈ VectorDomain(1)
    end

    @random begin
        η ~ MvNormal(Ω)
    end

    @covariates begin
        "Dose (mg)"
        dosenum
    end

    @pre begin
        rx = dosenum > 0 ? 1 : 0
        slope = tvslope*rx
        logit = intercept + slope + η[1]
    end

    @derived begin
        "Pain Relief"
        PainRelief ~ @. Bernoulli(logistic(logit))
    end
end

trt_param = (
    intercept = 0.001,
    tvslope = 0.0001,
    Ω = [1.0]
)
trt_model_fit = fit(trt_model,
                painrelief,
                trt_param,
                Pumas.FOCE())
```

```julia
trt_model_vpc = vpc(trt_model_fit, 
                stratify_by=[:dosenum])

trt_model_vpcplot = vpc_plot(trt_model_vpc; columns = 2, rows = 2)
```

```julia
cmax_model = @model begin
    @metadata begin
        desc = "Logistic Regression Model"
    end
    @param begin
        "Intercept"
        intercept ∈ RealDomain(init=0.001)
        "Slope"
        tvslope ∈ RealDomain(init=0.0001)
        """
         - Ω
        """
        Ω ∈ VectorDomain(1)
    end

    @random begin
        η ~ MvNormal(Ω)
    end

    @covariates begin
        "Dose (mg)"
        dosenum
        "Maximum Concentration"
        cmax
    end

    @pre begin
        slope = tvslope*cmax
        logit = intercept + slope + η[1]
    end

    @derived begin
        "Pain Relief"
        PainRelief ~ @. Bernoulli(logistic(logit))
    end
end

cmax_param = (
    intercept = 0.001,
    tvslope = 0.0001,
    Ω = [1.0]
)
cmax_model_fit = fit(cmax_model,
                painrelief,
                cmax_param,
                Pumas.FOCE())
```

```julia
cmax_model_vpc = vpc(cmax_model_fit, 
                stratify_by=[:dosenum])

cmax_model_vpcplot = vpc_plot(cmax_model_vpc; columns = 2, rows = 2)
```

```julia
cmax_model_vpc = vpc(cmax_model_fit, 
                    stratify_by=[:dosenum], 
                    covariates = [:cmax])

cmax_model_vpcplot = vpc_plot(cmax_model_vpc)
```


```julia
cmax_emax_model = @model begin
    @metadata begin
        desc = "Logistic Regression Model"
    end
    @param begin
        "Intercept"
        intercept ∈ RealDomain(init=0.001)
        "EC50"
        tvec50 ∈ RealDomain(init=4)
        """
         - Ω
        """
        Ω ∈ VectorDomain(1)
    end

    @random begin
        η ~ MvNormal(Ω)
    end

    @covariates begin
        "Dose (mg)"
        dosenum
        "Maximum Concentration"
        cmax
    end

    @pre begin
        ec50 = tvec50 
        logit = intercept * (1 + cmax / (ec50 + cmax)) + η[1]
    end

    @derived begin
        "Pain Relief"
        PainRelief ~ @. Bernoulli(logistic(logit))
    end
end

cmax_emax_param = (
    intercept = 0.001,
    tvec50 = 4,
    Ω = [1.0]
)
cmax_emax_model_fit = fit(cmax_emax_model,
                painrelief,
                cmax_emax_param,
                Pumas.FOCE())
```

```julia
cmax_emax_model_vpc = vpc(cmax_emax_model_fit, 
                stratify_by=[:dosenum])

cmax_emax_model_vpcplot = vpc_plot(cmax_emax_model_vpc; columns = 2, rows = 2)[1]
```

```julia
cmax_emax_model_vpc = vpc(cmax_emax_model_fit, 
                    covariates = [:cmax])

cmax_emax_model_vpcplot = vpc_plot(cmax_emax_model_vpc)[1]
```


```julia
conc_model = @model begin
    @metadata begin
        desc = "Logistic Regression Model"
    end
    @param begin
        "Intercept"
        intercept ∈ RealDomain(init=0.001)
        "EC50"
        tvec50 ∈ RealDomain(init=4)
        """
         - Ω
        """
        Ω ∈ VectorDomain(1)
    end

    @random begin
        η ~ MvNormal(Ω)
    end

    @covariates begin
        "Dose (mg)"
        dosenum
        "Concentration"
        Conc
    end

    @pre begin
        ec50 = tvec50 
        logit = intercept * (1 + Conc / (ec50 + Conc)) + η[1]
    end

    @derived begin
        "Pain Relief"
        PainRelief ~ @. Bernoulli(logistic(logit))
    end
end

conc_param = (
    intercept = 0.001,
    tvec50 = 4,
    Ω = [1.0]
)
conc_model_fit = fit(conc_model,
                painrelief,
                conc_param,
                Pumas.FOCE())
```

```julia
conc_model_vpc = vpc(conc_model_fit, 
                stratify_by=[:dosenum])

conc_model_vpcplot = vpc_plot(conc_model_vpc; columns = 2, rows = 2)[1]
```

```julia
conc_model_vpc = vpc(conc_model_fit, 
                    covariates = [:cmax])

conc_model_vpcplot = vpc_plot(conc_model_vpc)[1]
```

### Ordinal Regression of Pain Score


```julia
pkpain_df.PainScore .+= 1
```

```julia
pain_score = read_pumas(pkpain_df,
  id = :Subject,
  time = :Time,
  observations = [:PainScore],
  covariates = [:dosenum, :cmax, :Conc],
  event_data=false)
``` 

```julia
score_conc_model = @model begin
  @param begin
    b₁    ∈ RealDomain(init=2.90692)
    b₂    ∈ RealDomain(init=-2.97771, lower=-1000000, upper=1)
    b₃    ∈ RealDomain(init=-2.7541 , lower=-1000000, upper=1)
    slope ∈ RealDomain(init=0.01)
    ω     ∈ RealDomain(init=sqrt(3.10532), lower = 0.001)
  end

  @random begin
    η ~ Normal(0.0, ω)
  end

  @covariates Conc dosenum

  @pre begin
    effect = slope * Conc
    #Logit of cumulative probabilities
    lge₀ = @. b₁ + η + effect
    lge₁ = @. lge₀ + b₂
    lge₂ = @. lge₁ + b₃

    #Probabilities of >=0 and >=1 and >=2
    pge₀ = @. exp(lge₀) / (1.0 + exp(lge₀))
    pge₁ = @. exp(lge₁) / (1.0 + exp(lge₁))
    pge₂ = @. exp(lge₂) / (1.0 + exp(lge₂))

    #Probabilities of Y=0,1,2,3
    p₀ = @. 1.0 - pge₀
    p₁ = @. pge₀ - pge₁
    p₂ = @. pge₁ - pge₂
    p₃ = @. pge₂
  end

  @derived begin
    PainScore ~ @. Categorical(p₀, p₁, p₂, p₃)
  end
end
```

```julia
score_conc_model_fit = fit(score_conc_model,
                pain_score,
                init_params(score_conc_model),
                Pumas.FOCE())
```                

```julia
probtable = predict(score_conc_model_fit) |> DataFrame
#probstable(score_conc_model_fit)
#probfig = Figure()
#Axis(probfig[1,1])
#lines!(probtable.time, probtable.PainScore_pred, color=probtable.PainScore)
#probfig
```
```julia
score_conc_model_vpc = vpc(score_conc_model_fit, 
                stratify_by=[:dosenum])

score_conc_model_vpcplot = vpc_plot(score_conc_model_vpc, 
                                    columns = 4, 
                                    rows = 4, 
                                    fontsize = 12)[1]   
```

### Survival Analysis